package com.homedepot.di.xd.efs.businesshelper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.log4j.Logger;

import com.homedepot.di.xd.efs.constants.EFSConstants;
import com.homedepot.di.xd.efs.constants.UploadConstants;
import com.homedepot.di.xd.efs.dao.ScheduleUploadDAO;
import com.homedepot.di.xd.efs.exception.EFSException;
import com.homedepot.di.xd.efs.to.InputFileTO;
import com.homedepot.di.xd.efs.to.ResponseTO;
import com.homedepot.di.xd.efs.to.ScheduleOrderDayTO;
import com.homedepot.di.xd.efs.to.ScheduleTO;
import com.homedepot.di.xd.efs.util.EFSUtil;
import com.homedepot.di.xd.efs.util.UploadValidationUtil;

public class ScheduleUploadProcessor implements IUploadProcessor {


	private static final Logger LOGGER = Logger
			.getLogger(ScheduleUploadProcessor.class);

	@Override
	public void processFile(InputFileTO fileObj, ResponseTO responseTO)
			throws IOException, EFSException {
		processValidHeaderDataForSchedule(fileObj, responseTO);
	}

	/**
	 * This method is to validate the uploaded file headers
	 */
	public int validateHeader(String[] uploadedHeader) {

		if(LOGGER.isDebugEnabled()){
			LOGGER.debug( UploadConstants.ENTERING_METHOD + "validateHeader");
		}

		int hdrValidationCode = UploadValidationUtil.validateHeaderFields(uploadedHeader,
				UploadConstants.getScheduleHeader());

		if(LOGGER.isDebugEnabled()){
			LOGGER.debug("Schedule Upload header validation return code is "+hdrValidationCode);
			LOGGER.debug( UploadConstants.EXIT_METHOD + "validateHeader");
		}
		return hdrValidationCode;
	}


	/**
	 * Process the Schedule Data
	 *  
	 * @param fileObj
	 * @param responseTO
	 * @throws EFSException
	 */
	public static void processValidHeaderDataForSchedule(InputFileTO fileObj,
			ResponseTO responseTO) throws EFSException{

		if(LOGGER.isDebugEnabled()){
			LOGGER.debug( UploadConstants.ENTERING_METHOD + "processValidHeaderDataForSchedule");
		}

		Map<String, List<ScheduleTO>> validMap = new HashMap<>();
		List<ScheduleTO> scheduleTOList = null;
		List<ScheduleTO> inValidList = new ArrayList<>();
		List<ScheduleTO> validScheduleList = new ArrayList<>();
		List<Short> scheduleTypeCode = new ArrayList<>();
		List<String> validTypeGroupCodeList = new ArrayList<>();
		List<String> destinationList = new ArrayList<>();
		Map<Integer, Object[]> fileContents = null;
		Map<String, String> locationLastWorkDayCode = null;

		try{

			StringBuilder errString = null;

			//Read the file content
			fileContents = fileObj.getFileContents();

			//To get the Last Working day and Hours for all locations 
			locationLastWorkDayCode = ScheduleUploadDAO.getMaxWorkDayForLocation();

			// Read each record in the file and validate
			for (Map.Entry<Integer, Object[]> entry : fileContents.entrySet()){

				if(entry.getKey() == 0){
					continue;
				}

				Object[] row = entry.getValue();
				errString = new StringBuilder();

				ScheduleTO scheduleTo = null; // = new ScheduleTO();
				String origin = null; 
				String destination = null;
				String scheduleType =null;
				short scheduleGroup = 0;

				//If Origin ID is invalid add it to error string
				if (!UploadValidationUtil.isOriginValid(row[UploadConstants.FIRST].toString())) {
					errString.append(UploadConstants.INVALID_ORIGIN);
				}else{
					origin = row[UploadConstants.FIRST].toString();
				}

				// If Destination ID is invalid add it to error string
				if (!UploadValidationUtil.isDestinationValid(row[UploadConstants.SECOND].toString())) {
					errString.append(UploadConstants.INVALID_DESTINATION);
				}else{
					destination = row[UploadConstants.SECOND].toString();
					destinationList.add(destination);
				}

				// If Schedule Type Code is invalid add it to error string
				if (!UploadValidationUtil.isNumeric(row[UploadConstants.THIRD].toString())) {
					errString.append(UploadConstants.INVALID_SCHEDULE_TYP_CD);
				}else{
					scheduleType = row[UploadConstants.THIRD].toString();
				}

				// If Schedule Group Code is null then Default to 1 .
				if(row[UploadConstants.FOURTH] ==null){
					scheduleGroup = (short) UploadConstants.ONE;

				}
				else{
					//If Schedule Group Code is invalid add it to error string
					if(!UploadValidationUtil.isNumeric(row[UploadConstants.FOURTH].toString()))
					{
						errString.append(UploadConstants.INVALID_SCHEDULE_GRP_CD);
					}
					else
					{
						scheduleGroup = (short)row[UploadConstants.FOURTH];
					}
				}


				// Check if  Effective begin date exist
				// if exist then convert that into Util.Date format
				if(row[UploadConstants.TWENTYFIVE] == null){
					errString.append(UploadConstants.INVALID_EFF_BGN_DT);
				}

				// Check if  Effective begin date exist
				// if exist then convert that into Util.Date format
				if(row[UploadConstants.TWENTYSIX] == null){
					errString.append(UploadConstants.INVALID_EFF_END_DT);
				}


				/**
				 * Check in ValidMap for existence of a record in below combination
				 * if (Location + Destination + Schedule Type CD + Schedule Group CD ) exist.
				 * 		Check for Order Day existence in scheduleOrderDayTO List
				 * 
				 *  Valid OrderDay is from 1 to 7 
				 */
				String key = origin+"_"+destination+"_"+scheduleType+"_"+scheduleGroup; //+"_"+effBeginDt+"_"+effEndDt;
				LOGGER.debug("ValidMap Key is"+key); 

				// This is to handle multiple rows in excel
				if(validMap.get(key) != null){

					java.sql.Date effBeginDate = UploadValidationUtil.convertSUtilDateToSqlDate(row[UploadConstants.TWENTYFIVE]);
					java.sql.Date effEndDate = UploadValidationUtil.convertSUtilDateToSqlDate(row[UploadConstants.TWENTYSIX]);
					for(ScheduleTO to: validMap.get(key)){

						/*
						 * Check if Effective dates are getting overlaps if yes then check the Order Day
						 */
						LOGGER.debug("Incoming Dates are :  "+effBeginDate +'\t'+effEndDate); 
						LOGGER.debug("Dates already present in TO " +to.getEffectiveBeginDate() +'\t'+to.getEffectiveEndDate());
						if(!UploadValidationUtil.isDateRangeOverlapping(to.getEffectiveBeginDate(), to.getEffectiveEndDate(), 
								effBeginDate, effEndDate)){
							// Need to create a new ScheduleTO to keep different effective Dates 
							scheduleTo = new ScheduleTO();
							scheduleTo.setOriginNumber(origin);
							scheduleTo.setScheduleGroupCode(scheduleGroup);
							populateScheduleTO(scheduleTo, row, errString,fileObj, locationLastWorkDayCode);

							//finally add the scheduleTO to Map 
							if(errString.length() > 0){
								scheduleTo.setErrorString(errString.toString());
								inValidList.add(scheduleTo);
							}else{

								// Adding in these list for latest Database Validation
								scheduleTypeCode.add(scheduleTo.getScheduleTypeCode());
								LOGGER.debug("scheduleTOList Size before"+scheduleTOList.size());
								scheduleTOList.add(scheduleTo);
								LOGGER.debug("scheduleTOList Size after"+scheduleTOList.size());
								validMap.put(key, scheduleTOList);
								break;
							}
						}else{

							// Check to ensure Order day is also not overlapping
							/**
							 * Compare the EFF_DTs from tempTO and compare with the incoming row 
							 * variables eff_dts to find if there is any Overlapping exists
							 */
							Map<Short, ScheduleOrderDayTO> orderDayToMap = to.getScheduleOrderDayTO();

							if(orderDayToMap!=null){
								ScheduleOrderDayTO orderDayTo = null;
								Short orderDay = null;
								if(row[UploadConstants.SIX]!=null){
									orderDay = (Short) row[UploadConstants.SIX];

									/**
									 * Check to see there is any Order Day object exists 
									 * if Not create a new ScheduleOrderDayTO and add in Map
									 * if exist throw error for duplicate order day record
									 */ 
									if(orderDayToMap.get(orderDay) == null){
										LOGGER.debug("Building a new orderDay" +orderDay);
										orderDayTo = new ScheduleOrderDayTO();
										populateScheduleOrderDayTO(orderDayTo,row,orderDay, errString,fileObj, locationLastWorkDayCode);
										LOGGER.debug("orderDayToMap size before" +orderDayToMap.size());
										orderDayToMap.put(orderDay, orderDayTo);
										LOGGER.debug("orderDayToMap size after" +orderDayToMap.size());
									}else{
										LOGGER.debug( UploadConstants.INVALID_ORDER_DAY_RECORD);
										errString.append(UploadConstants.INVALID_ORDER_DAY_RECORD + orderDay);
									}
								}else{
									LOGGER.debug("Order Day is null");
									errString.append(UploadConstants.INVALID_ORDER_DAY + orderDay);
									//continue;
								}
							}

							if(errString.length() > 0){
								LOGGER.debug("Building the Invalid TO");
								scheduleTo = new ScheduleTO();
								scheduleTo.setErrorString(errString.toString());
								scheduleTo.setOriginNumber(origin);
								scheduleTo.setScheduleGroupCode(scheduleGroup);
								scheduleTo.setDestinationNumber((int)row[UploadConstants.SECOND]);
								scheduleTo.setScheduleTypeCode((short)row[UploadConstants.THIRD]);
								scheduleTo.setEffectiveBeginDate(UploadValidationUtil.convertSUtilDateToSqlDate(row[UploadConstants.TWENTYFIVE]));
								scheduleTo.setEffectiveEndDate(UploadValidationUtil.convertSUtilDateToSqlDate(row[UploadConstants.TWENTYSIX]));
								scheduleTo.setCreatedUserId(fileObj.getUserId());
								scheduleTo.setLastUptdUserId(fileObj.getUserId());
								// Check for Schedule Name exist or not
								scheduleTo.setScheduleName(row[UploadConstants.FIVE].toString());
								if (!UploadValidationUtil.isValidStringLength(row[UploadConstants.FIVE].toString(), 100)) {
									errString.append(UploadConstants.INVALID_SCHEDULE_NAME);
								}
								LOGGER.debug("InvalidTO list size before"+inValidList.size());
								inValidList.add(scheduleTo);
								LOGGER.debug("InvalidTO list size after"+inValidList.size());
							}
						}
					}
				}else{

					// First time adding the ScheduleTO to validMap
					scheduleTo = new ScheduleTO();
					scheduleTo.setOriginNumber(origin);
					scheduleTo.setScheduleGroupCode(scheduleGroup);
					populateScheduleTO(scheduleTo, row, errString,fileObj, locationLastWorkDayCode);

					//finally add the scheduleTO to Map 
					if(errString.length() > 0){
						scheduleTo.setErrorString(errString.toString());
						inValidList.add(scheduleTo);
					}else{

						// Adding in these list for latest Database Validation
						scheduleTypeCode.add(scheduleTo.getScheduleTypeCode());
						scheduleTOList = new ArrayList<>();
						scheduleTOList.add(scheduleTo);
						LOGGER.debug("Valid Map Size before"+validMap.size());
						validMap.put(key, scheduleTOList);
						LOGGER.debug("Valid Map Size after"+validMap.size());
					}
				}

			} //end of Iterating Data
			LOGGER.debug("Valid TO List size :"+validMap.size());
			LOGGER.debug("Invalid TO List size :" +inValidList.size());
			
			for (Entry<String, List<ScheduleTO>> entry : validMap.entrySet())
			{
				//Fetching the list of TOs from the corresponding map entry
				validScheduleList.addAll((new ArrayList<>(entry.getValue())) );
			}

			// Not required since we can achieve using 2nd query itself
			// validScheduleTypeCode = ScheduleUploadDAO.validateScheduleTypeCode(scheduleTypeCode);
			if(validScheduleList.size()>0)
			{
				// Validating against the Database for existence of Type Code and associated Group Code.	
				validTypeGroupCodeList = ScheduleUploadDAO.validateScheduleGroupCode(scheduleTypeCode);
			}
			
			/*
			 * Validate the Schedule Type and Group code combination 
			 */
			for(ScheduleTO to: validScheduleList){
				String item = to.getScheduleTypeCode() +"_" + to.getScheduleGroupCode();
				if(!validTypeGroupCodeList.contains(item)){
					to.setErrorString(UploadConstants.INVALID_SCHEDULE_GRP_TYP_CD);
					inValidList.add(to);
				}
			}

			validScheduleList.removeAll(inValidList);

			LOGGER.debug("Valid ScheduleList Size to be inserted is/are "+validScheduleList.size());
			LOGGER.debug("Invalid records found is/are "+inValidList.size());
			
			//List of DTO to be Populated in Database.
			ScheduleUploadDAO.insertRecords(validScheduleList, inValidList);

		}catch(Exception e){
			throw new EFSException(
					EFSConstants.EXCEPTION_OCCURED, e);
		}
		if(LOGGER.isDebugEnabled()){
			LOGGER.debug( UploadConstants.EXIT_METHOD + "processValidHeaderDataForLane");
		}
	}

	/**
	 * To populate the ScheduleTO with the input data
	 * 
	 * @param scheduleTo
	 * @param row
	 * @param errString
	 * @param fileObj
	 * @param locationLastWorkDayCode
	 */
	public static void populateScheduleTO(ScheduleTO scheduleTo,  Object[] row, StringBuilder errString, 
			InputFileTO fileObj, Map<String, String> locationLastWorkDayCode){

		scheduleTo.setDestinationNumber((int)row[UploadConstants.SECOND]);
		scheduleTo.setScheduleTypeCode((short)row[UploadConstants.THIRD]);
		scheduleTo.setEffectiveBeginDate(UploadValidationUtil.convertSUtilDateToSqlDate(row[UploadConstants.TWENTYFIVE]));
		scheduleTo.setEffectiveEndDate(UploadValidationUtil.convertSUtilDateToSqlDate(row[UploadConstants.TWENTYSIX]));
		scheduleTo.setCreatedUserId(fileObj.getUserId());
		scheduleTo.setLastUptdUserId(fileObj.getUserId());
		// Check for Schedule Name exist or not
		scheduleTo.setScheduleName(row[UploadConstants.FIVE].toString());
		if (!UploadValidationUtil.isValidStringLength(row[UploadConstants.FIVE].toString(), 100)) {
			errString.append(UploadConstants.INVALID_SCHEDULE_NAME);
		}

		ScheduleOrderDayTO orderDayTo = new ScheduleOrderDayTO();
		Short orderDay = null;

		if(row[UploadConstants.SIX]!=null){
			orderDay = (Short) row[UploadConstants.SIX];
			// Populates Order Day DTO
			populateScheduleOrderDayTO(orderDayTo,row,orderDay, errString,fileObj, locationLastWorkDayCode);
			Map<Short, ScheduleOrderDayTO> orderDayToMap = new HashMap<>();
			orderDayToMap.put(orderDay, orderDayTo);
			scheduleTo.setScheduleOrderDayTO(orderDayToMap);
		}else{
			errString.append(UploadConstants.INVALID_ORDER_DAY + orderDay);
		}


	}

	/**
	 * Method populates the ScheduleOrderDayTO with the input data
	 * 
	 * @param orderDayTo
	 * @param row
	 * @param orderDay
	 * @param errString
	 */
	public static void populateScheduleOrderDayTO(ScheduleOrderDayTO orderDayTo, Object[] row,Short orderDay, 
			StringBuilder errString,InputFileTO fileObj, Map<String, String> locationLastWorkDayCode){

		//Setting Order Day
		orderDayTo.setOrderDayOfWeekCode((short)row[UploadConstants.SIX]);
		if(!UploadValidationUtil.isValidWeekDayNumber(row[UploadConstants.SIX].toString())){
			errString.append(UploadConstants.INVALID_ORDER_DAY);
		}

		//Check if shipDay exist
		//Calculate VTT if ship Day exist
		orderDayTo.setShipmentBeginDayOfWeekCode((short) row[UploadConstants.EIGHT]);  //NINE
		orderDayTo.setShipmentEndDayOfWeekCode((short) row[UploadConstants.EIGHT] );
		Short shipDay = null;
		if(!UploadValidationUtil.isValidWeekDayNumber(row[UploadConstants.EIGHT].toString())){
			errString.append(UploadConstants.INVALID_SHIP_DAY);
		}							
		else {
			shipDay=(Short) row[UploadConstants.EIGHT]; 
			LOGGER.debug("Ship day is"+shipDay+'\t'+"Order day is"+orderDay);
			orderDayTo.setVendorTransportationTimeHours(
					UploadValidationUtil.calculateVendorTranspTime(shipDay,orderDay, locationLastWorkDayCode));
			LOGGER.debug("VTT is" +orderDayTo.getVendorTransportationTimeHours());
		}

		//Check if Arrival Day exist
		orderDayTo.setArrivalBeginDayOfWeekCode((short) row[UploadConstants.NINE]); //TEN
		orderDayTo.setArrivalEndDayOfWeekCode((short) row[UploadConstants.NINE]);
		if(!UploadValidationUtil.isValidWeekDayNumber(row[UploadConstants.NINE].toString())){
			errString.append(UploadConstants.INVALID_ARRIVAL_DAY);
		}

		//Check if vendor Ready Time exist
		orderDayTo.setOriginLocationShipmentBeginTime(EFSUtil.convertToValidTimeFormat(row[UploadConstants.TEN].toString())); //ELEVEN
		orderDayTo.setOriginLocationShipmentEndTime(EFSUtil.convertToValidTimeFormat( row[UploadConstants.TEN].toString()));
		if(!UploadValidationUtil.isValidTimeFormat(row[UploadConstants.TEN].toString())){
			errString.append(UploadConstants.INVALID_VNDR_RD_TYM);
		}

		//Check if  Carrier Depart Time exist
		orderDayTo.setExpectedCarrierDepartTime(EFSUtil.convertToValidTimeFormat(row[UploadConstants.ELEVEN].toString()));//TWELVE
		if(!UploadValidationUtil.isValidTimeFormat(row[UploadConstants.ELEVEN].toString()))
		{
			errString.append(UploadConstants.INVALID_CARRIER_DEPT_TYM);
		}

		//Check if Shipment Transit Time exist
		orderDayTo.setExpectedShipmentTransitTimeHours((short) row[UploadConstants.TWELVE]); //THIRTEEN
		if(!UploadValidationUtil.isNumeric(row[UploadConstants.TWELVE].toString()))
		{
			errString.append(UploadConstants.INVALID_SHPMNT_TRANS_TIME);
		}

		//Check if DC Appointment Time exist
		orderDayTo.setExpectedCarrierArrivalBeginTime(EFSUtil.convertToValidTimeFormat(row[UploadConstants.THIRTEEN].toString()));//FOURTEEN
		orderDayTo.setExpectedCarrierArrivalEndTime(EFSUtil.convertToValidTimeFormat( row[UploadConstants.THIRTEEN].toString()));
		if(!UploadValidationUtil.isValidTimeFormat(row[UploadConstants.THIRTEEN].toString()))
		{
			errString.append(UploadConstants.INVALID_DC_APP_TYM);
		}

		//Check if DC Start Work Day exist
		orderDayTo.setDcBeginShipmentWorkDayOfWeekCode((short) row[UploadConstants.FOURTEEN]);//FIFTEEN
		if(!UploadValidationUtil.isValidWeekDayNumber(row[UploadConstants.FOURTEEN].toString()))
		{
			errString.append(UploadConstants.INVALID_DC_START_WORK_DAY);

		}

		//Check if DC End Work Day exist
		orderDayTo.setDcEndShipmentWorkDayOfWeekCode((short) row[UploadConstants.FIFTEEN]);//SIXTEEN
		if(!UploadValidationUtil.isValidWeekDayNumber(row[UploadConstants.FIFTEEN].toString())){
			errString.append(UploadConstants.INVALID_DC_END_WORK_DAY);
		}

		//Check if DC Start Shift Sequence Number exists
		orderDayTo.setDcBeginWorkShiftSequenceNumber((short) row[UploadConstants.SIXTEEN]);//SEVENTEEN
		if(!UploadValidationUtil.isNumeric( row[UploadConstants.SIXTEEN].toString()))
		{
			errString.append(UploadConstants.INVALID_DC_START_SHFT_SEQ_NBR);
		}

		//Check if DC End Shift Sequence Number exists
		orderDayTo.setDcEndWorkShiftSequenceNumber((short) row[UploadConstants.SEVENTEEN]);//EIGHTEEN
		if(!UploadValidationUtil.isNumeric( row[UploadConstants.SEVENTEEN].toString()))
		{
			errString.append(UploadConstants.INVALID_DC_END_SHFT_SEQ_NBR);
		}

		//Check if DC Shift Count exists
		orderDayTo.setDcShipmentWorkShiftCount((short) row[UploadConstants.EIGHTEEN]);//NINETEEN
		if(!UploadValidationUtil.isNumeric( row[UploadConstants.EIGHTEEN].toString()))
		{
			errString.append(UploadConstants.INVALID_DC_SHIFT_CNT);
		}

		//Calculating the Work hours based on RESPECTVIE DC 
		/*orderDayTo.setDcShipmentWorkHours(UploadValidationUtil.calculateWorkHours(locationLastWorkDayCode, 
				row[UploadConstants.SECOND].toString(), orderDayTo.getDcShipmentWorkShiftCount()));*/
		orderDayTo.setDcShipmentWorkHours(orderDayTo.getDcShipmentWorkShiftCount() * UploadConstants.DC_WORK_HOURS);

		//Check if OrderWeek Number exists if not populate as ZERO -- No need to set
		//orderDayTo.setOrderDayOfWeekCode((short) row[UploadConstants.NINETEEN]);//TWENTY
		
		//Check if  Tender Relative Week Number exists
		orderDayTo.setTenderRelativeWeekNumber((short) row[UploadConstants.TWENTY]);//TWENTYONE
		if(!UploadValidationUtil.isNumber( row[UploadConstants.TWENTY].toString()))
		{
			errString.append(UploadConstants.INVALID_TNDR_RTV_WK_NBR);
		}

		//Check if Ship Week Number exists
		orderDayTo.setShipmentBeginRelativeWeekNumber((short) row[UploadConstants.TWENTYONE]);//TWENTYTWO
		orderDayTo.setShipmentEndRelativeWeekNumber((short) row[UploadConstants.TWENTYONE]);
		if(!UploadValidationUtil.isNumeric( row[UploadConstants.TWENTYONE].toString()))
		{
			errString.append(UploadConstants.INVALID_SHP_WK_NBR);
		}

		//Check if Arrive Week Number exists
		orderDayTo.setArrivalBeginRelativeWeekNumber((short) row[UploadConstants.TWENTYTWO]);//TWENTYTHREE
		orderDayTo.setArrivalEndRelativeWeekNumber((short) row[UploadConstants.TWENTYTWO]);
		if(!UploadValidationUtil.isNumeric( row[UploadConstants.TWENTYTWO].toString()))
		{
			errString.append(UploadConstants.INVALID_ARRIVE_WK_NBR);
		}

		//Check if DC Start Work Week Number exists
		orderDayTo.setDcBeginShipmentWorkRelativeWeekNumber((short) row[UploadConstants.TWENTYTHREE]);//TWENTYFOUR
		if(!UploadValidationUtil.isNumeric( row[UploadConstants.TWENTYTHREE].toString()))
		{
			errString.append(UploadConstants.INVALID_DC_STRT_WRK_WK_NBR);
		}

		//Check if DC End Work Week Number exists
		orderDayTo.setDcEndShipmentWorkRelativeWeekNumber((short) row[UploadConstants.TWENTYFOUR]);//TWENTYFIVE
		if(!UploadValidationUtil.isNumeric( row[UploadConstants.TWENTYFOUR].toString()))
		{
			errString.append(UploadConstants.INVALID_DC_END_WRK_WK_NBR);
		}
		orderDayTo.setCreatedUserId(fileObj.getUserId());
		orderDayTo.setLastUptdUserId(fileObj.getUserId());

	}

}
